"""
sitecustomize.py is automatically imported by Python when the interpreter
is initialized, allowing to adjust sys.path for our project.
For a better chance to be used, the file can be placed next to the site.py
file in the embedded python environment.

/!\ Be careful not doing too much prints in this file, as it can lead to
    an IOError(9, 'Bad file descriptor') exception when the interpreter
    is initialized from C/C++ code, making the module import fail.
"""
import os
import sys
import site

IS_WIN = sys.platform.startswith('win')

# Whether we use a standalone python distribution or a virtual env that is
# linked to another python install (set at CMake configuration time)
IS_STANDALONE_PYTHON = '${EMBEDDED_PYTHON}' == 'TRUE'

if IS_STANDALONE_PYTHON and site.ENABLE_USER_SITE:
    # let's remove the user site-packages dir from sys.path, to try to be
    # isolated from packages potentially already installed on the system.
    # This has the same effect as running python with the -s option.
    # ... except if .pth files exist in the user site dir: in this case the
    # paths listed in these files are added in sys.path (one way to discard
    # them is to enable STRICT_PATH_ISOLATION).
    user_site = site.USER_SITE
    # using a while loop because in certain contexts it can be there 2 times ...
    while user_site in sys.path:
        sys.path.remove(user_site)

# Whether to only allow sys.path to contain directories that are inside
# our local environment, ensuring a strict isolation from packages
# installed on the system.
# If enabled, any external path added with the PYTHONPATH env var will be
# discarded, as well as any external folder like the ones listed by
# .pth files that could exist for e.g. in the user site dir.
# Even if not enabled, we give a priority to directories inside the
# local env, especially to limit side effects and still be able to use
# packages installed in editable mode, or to still be able to use the
# PYTHONPATH env var for testing needs.
STRICT_PATH_ISOLATION = False

# Determine a root 'prefix' dir from which we assume our local environment starts
LOCAL_ENV_ROOT = os.path.abspath(os.path.join(sys.prefix, '..'))

# Lower the priority of external directories that are in sys.path, or totally
# discard them
sys_path = sys.path
for p in sys_path[:]:
    if not p.startswith(LOCAL_ENV_ROOT):
        sys_path.remove(p)
        if not STRICT_PATH_ISOLATION:
            # we move it later in sys.path instead of removing it
            # (ensuring a priority on local modules/packages)
            sys_path.append(p)

if not IS_WIN:
    # On Linux we install binaries and libs in distinct folders, and
    # the lib folder should be in the python path, especially to be able
    # to import the ISSofaPython compiled module.
    # If the python home is properly set before initializing the interpreter
    # in the C++ code, sys.prefix should be the absolute root path of the
    # python env of the project.
    for reldir in ('..', '../..'):
        lib_dir = os.path.join(sys.prefix, reldir, 'lib')
        if os.path.exists(os.path.join(lib_dir, 'ISSofaPython.so')):
            sys.path.insert(0, os.path.abspath(lib_dir))
            break
